= Microservices : un √©tat des lieux
Thomas SCHWENDER <https://github.com/ardemius[@ardemius]>
// Handling GitHub admonition blocks icons
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: ./images
:source-highlighter: highlightjs
// Next 2 ones are to handle line breaks in some particular elements (list, footnotes, etc.)
:lb: pass:[<br> +]
:sb: pass:[<br>]
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:toclevels: 2
// To turn off figure caption labels and numbers
:figure-caption!:

toc::[]

NOTE: Cet article se base sur le talk https://www.youtube.com/watch?v=2VH8rQSKdk0[Microservices: Infinity War! Spring vs MicroProfile] que j'ai donn√© √† *Devoxx France 2019* avec ma coll√®gue Darren Boutros.

== Microservices : un rien d'histoire et de contexte

On peut voir l‚Äô*architecture microservices* comme une √©volution l‚Äôarchitecture *SOA* (Service Oriented Architecture), elle-m√™me cr√©√©e pour pallier aux inconv√©nients des *applications monolithiques*.

image:microservices-etat-des-lieux_01.jpg[]

* Un des points int√©ressants √† remarquer dans la transition SOA vers l‚Äôarchitecture microservices, est la *suppression de l‚ÄôESB* (Enterprise Service Bus). +
La communication entre les services devait √™tre la principale fonction de ce composant, mais il embarquait fr√©quemment une *trop grande complexit√© m√©tier*. +
Pour corriger cela, il a √©t√© *remplac√© par les endpoints REST des microservices*. +
Pour illustrer ce changement, Martin Fowler palera de _"Smart endpoints and Dumb pipes"_

* On constate √©galement que l'on ne travaille plus avec un seul et unique runtime, mais avec *1 runtime par microservice*, ce qui participe √† garantir une de leurs principales caract√©ristiques :  l'*isolation*.

=== L'inspiration des microservices

En 2005, Alistair Cockburn pr√©sentait l‚Äô*architecture hexagonale* (ou mod√®le *‚ÄúPorts and Adapters‚Äù*) afin de permettre la conception d‚Äôapplications pouvant √™tre test√©es en *isolation de leurs runtimes et bases de donn√©es*.

Cela a √©t√© l‚Äôinspiration pour l‚Äôarchitecture microservices, dont Alistair donna ensuite la d√©finition suivante : _‚ÄúAn architectural style or an approach for building IT systems as a set of business capabilities that are autonomous, self contained, and loosely coupled‚Äù_

=== Architecture hexagonale

image::microservices-etat-des-lieux_02.jpg[]

IMPORTANT: Le principe fondateur de ce pattern est que [red]*le m√©tier ne doit d√©pendre de rien* : TOUTES les d√©pendances vont de *l‚Äôext√©rieur vers l‚Äôint√©rieur*.

Le but principal de cette architecture ne date pas d'hier, il est question de *s√©parer clairement le m√©tier de l'impl√©mentation technique* (notion d'*isolation*).

* Tout ce qui se trouve √† [red]*gauche de l'hexagone* repr√©sente [red]*les composants qui ont besoin de ce dernier*. +
On trouve c√¥t√© gauche des *interfaces expos√©es pour les composants ayant besoin d'invoquer le mod√®le*. On parle d'*API*, pour _Application Provider Interfaces_. +
-> Les composants souhaitant communiquer avec notre m√©tier le feront au travers d‚Äô*adaptateurs qui contacteront nos API*.

* Tout ce qui se trouve √† [red]*droite de l'hexagone* repr√©sente [red]*les composants dont ce dernier a besoin*. +
On trouve c√¥t√© droit des *interfaces expos√©es pour les composants que le mod√®le a besoin d‚Äôinvoquer*. On parle de *SPI*, pour _Service Provider Interfaces_. +
-> Les composants avec lesquels notre m√©tier souhaite communiquer seront contact√©s au travers des *SPI dont les impl√©mentations seront r√©solues √† l‚Äôex√©cution et fournies par des adaptateurs*.

=== Isolation

image::microservices-etat-des-lieux_03.jpg[align="center"]

Comme nous le verrons plus en d√©tail par la suite, la notion d'*isolation* est capitale pour les microservices, or *l'isolation am√®ne la redondance*, et cette derni√®re, on nous a appris √† la "combattre" depuis des dizaines d'ann√©es. +
Rappelez-vous le principe introduit dans https://www.amazon.fr/Pragmatic-Programmer-Journeyman-Master/dp/020161622X[_The Pragmatic Programmer_] : *Don't Repeat Yourself (DRY)*.

Prenons le cas de 2 classes partageant un m√™me comportement. +
Comme on nous l'a appris en programmation OO, on aura g√©n√©ralement tendance √† sortir ce comportement commun dans une classe de plus haut niveau, qui sera ensuite h√©rit√©e. +
Si on change le comportement de la classe m√®re, on impacte donc les 2 classes filles. +
Cet h√©ritage a donc augment√© le couplage entre nos classes.

[NOTE]
====
L'exemple pr√©c√©dent est... juste un exemple pour illustrer un probl√®me classique de couplage üòÖ +
On pourrait faire diff√©remment, en utilisant la composition ou d'autres patterns (ne me tappez pas... üòâ)
====

Dans le cas des microservices, nous voulons √©viter un maximum tout couplage, afin que ces derniers soient le plus *ind√©pendants* possible.
Donc, entre *DRY et couplage*, et [red]*isolation et redondance*, la 2nd approche est privil√©gi√©e.

.DDD et redondance
[NOTE]
====
La conception des microservices pl√©biscite l'approche *DDD* (*Domain Driven Design*). +
Cette approche, tout particuli√®rement le d√©coupage en *bounded context*, nous encourage tr√®s fortement √† limiter le couplage, quitte √† "se r√©p√©ter" par moment. +
Ce qui fait pencher encore un peu plus la balance vers "l'isolation et redondance".

Si vous voulez plus de d√©tails sur ce point, je vous conseille l'excellente conf√©rence https://www.youtube.com/watch?v=xZOO_CksS-E[Hexagonal at Scale, with DDD and microservices!] de Cyrille Martraire, lors du Voxxed Days Microservices Paris 2018.
====

=== Pourquoi les microservices ?

Du fait du d√©veloppement d‚ÄôInternet, tout le monde communique avec tout le monde, et est en concurrence avec tout le monde. +
L‚Äô√©mergence des microservices est la cons√©quence de l‚Äô*√©volution de nos applications* pour faire face √† ces nouveaux besoins :

* *Complexit√© croissante* +
Les applications ne se limitent plus au seul data center de la compagnie, mais communiquent avec les services externes d‚Äôautres providers sur tout le globe.
* *Besoin de livrer de plus en plus vite* +
Quand la concurrence est partout, il faut pouvoir faire √©voluer son produit rapidement, et donc √™tre capable de livrer des nouvelles fonctionnalit√©s au plus t√¥t, sans devoir attendre de release compl√®te.
* *Besoin de performance et de scalabilit√©* +
Il faut √™tre capable de s‚Äôadapter aux mont√©es en charge d‚Äôun march√© potentiellement mondial : tr√®s vite scaler sur de multiples serveurs, et lib√©rer les ressources tout aussi vite quand le pic de charge est pass√©.
* *Doivent √™tre toujours disponibles* +
Du fait de la comp√©tition de plus en plus sauvage, si votre application tombe, votre client part chez le concurrent... Votre application doit √™tre r√©siliente, et √™tre capable de g√©rer les pannes (on parlera pour cela de _"Design for Failures"_).

Pour adresser ces probl√©matiques, des soci√©t√©s comme Netflix, Amazon, eBay commenc√®rent √† *casser leurs monolithes* en services :

* de petite taille, chacun ne remplissant qu‚Äôune fonction
* pouvant √™tre *d√©ploy√©s ind√©pendamment* les uns des autres.

Ces services *distribu√©s*, *petits*, *simples* et *d√©coupl√©s* permirent aux applications de devenir *scalables*, *r√©silientes* et *flexibles*. +
-> Ils prirent progressivement le nom de *microservices*.

NOTE: La *d√©coupe des applications monolithiques* en microservices est donc le *Use Case d‚Äôorigine* des microservices.

== Principaux Use Cases

* "L‚Äôoriginel (le pass√©)" : Migration d‚Äôun monolithe vers une architecture microservices
* "L‚Äôactuel (le pr√©sent)" : D√©veloppement d‚Äôapplications *cloud-native*

La transition aux applications Cloud-native est bien expliqu√©e dans le https://www.amazon.fr/Spring-Microservices-Action-John-Carnell/dp/1617293989[Spring Microservices in Action] p5 :

____
You *start* building microservices because they give you a *high degree of flexibility and autonomy* with your development teams, but you and your team quickly find that the *small, independent nature of microservices makes them easily deployable to the cloud*.
____

=== Approche Cloud-native

.Cloud-Native approach : https://pivotal.io/fr/cloud-native
image::microservices-etat-des-lieux_04.jpg[]

Les microservices sont maintenant l‚Äô*architecture "par d√©faut"* pour b√¢tir des applications Cloud-native.

L'approche Cloud-native a les grandes caract√©ristiques suivantes :

* *Architecture microservices* : implique de *multiples √©quipes ind√©pendates*, travaillant √† l'am√©lioration du syst√®me.
* *Continuous Delivery* : Le CD repr√©sente un *process d'automatisation* permettant aux d√©veloppeurs de *d√©ployer rapidement* vers les environnements de prodution
* *DevOps* : La culture DevOps rapproche d√©veloppeurs et OPs, et les aide √† livrer une meilleure *valeur partag√©e* au client.
* *Containerized* : La notion de container est capitale, car ce sont ces derniers qui permettent aux applications de pouvoir √™tre d√©ploy√©es *n'importe o√π*. +
Ce qui importe n'est pas OU ces derni√®res sont d√©ploy√©es, mais COMMENT elles le sont.

Voici une d√©finition de l'approche Cloud-native que j'aime particuli√®rement :

[quote, 'https://medium.com/walmartlabs/cloud-native-application-architecture-a84ddf378f82[Cloud Native Application Architecture]']
____
Cloud native is an approach for building applications as micro-services and *running* them on a *containerised and dynamically orchestrated platforms* that *fully exploits the advantages of the Cloud computing model*.
____

On y parle d'exploiter les avantages qu'offre la conception dans le Cloud, afin de r√©pondre aux nombreuses contraintes inh√©rentes au d√©veloppement de microservices. +
En effet, le d√©veloppement de ces derniers est complexe, principalement car *ils sont nombreux*. +
On ne d√©veloppe jamais un mais *DES* microservices, dont il faut assurer la communication, le cycle de vie, le monitoring, etc etc.
Tout cela n√©cessite la mise en place d'un *environnement complexe*, on parlera de [red]*capability model*.

[NOTE]
====
Ce terme de *capability model* n'est pas si courant dans la litt√©rature sur les microservices, mais je le trouve tr√®s appropri√©. +
La gestion des logs, le monitoring centralis√©, la d√©couverte des services, etc. sont autant de "capabilities" qu'il est n√©cessaire de mettre en place pour assurer le bon fonctionnement de nos microservices.

A la base, je l'ai trouv√© dans l'excellent article https://hub.packtpub.com/capability-model-microservices/[A capability model for microservices] de Rajesh RV, l'auteur de https://www.packtpub.com/application-development/spring-microservices[Spring Microservices].
====

== Capability model

La conception de microservices ne se limite pas au simple code du service lui-m√™me, l'environnement, la *capability model* comme nomm√© pr√©c√©demment, est essentiel.

video::microservices-etat-des-lieux_05.mp4[width=1000, start=0, end=10, options=autoplay]

