= Microservices : un état des lieux
Thomas SCHWENDER <https://github.com/ardemius[@ardemius]>
// Handling GitHub admonition blocks icons
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: ./images
:source-highlighter: highlightjs
// Next 2 ones are to handle line breaks in some particular elements (list, footnotes, etc.)
:lb: pass:[<br> +]
:sb: pass:[<br>]
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:toclevels: 2
// To turn off figure caption labels and numbers
:figure-caption!:

toc::[]

== Microservices : un rien d'histoire et de contexte

On peut voir l’*architecture microservices* comme une évolution l’architecture *SOA* (Service Oriented Architecture), elle-même créée pour pallier aux inconvénients des *applications monolithiques*.

image:microservices-etat-des-lieux_01.jpg[]

* Un des points intéressants à remarquer dans la transition SOA vers l’architecture microservices, est la *suppression de l’ESB* (Enterprise Service Bus). +
La communication entre les services devait être la principale fonction de ce composant, mais il embarquait fréquemment une *trop grande complexité métier*. +
Pour corriger cela, il a été *remplacé par les endpoints REST des microservices*. +
Pour illustrer ce changement, Martin Fowler palera de _"Smart endpoints and Dumb pipes"_

* On constate également que l'on ne travaille plus avec un seul et unique runtime, mais avec *1 runtime par microservice*, ce qui participe à garantir une de leurs principales caractéristiques :  l'*isolation*.

=== L'inspiration des microservices

En 2005, Alistair Cockburn présentait l’*architecture hexagonale* (ou modèle *“Ports and Adapters”*) afin de permettre la conception d’applications pouvant être testées en *isolation de leurs runtimes et bases de données*.

Cela a été l’inspiration pour l’architecture microservices, dont Alistair donna ensuite la définition suivante : _“An architectural style or an approach for building IT systems as a set of business capabilities that are autonomous, self contained, and loosely coupled”_

=== Architecture hexagonale

image::microservices-etat-des-lieux_02.jpg[]

IMPORTANT: Le principe fondateur de ce pattern est que [red]*le métier ne doit dépendre de rien* : TOUTES les dépendances vont de *l’extérieur vers l’intérieur*.

Le but principal de cette architecture ne date pas d'hier, il est question de *séparer clairement le métier de l'implémentation technique* (notion d'*isolation*).

* Tout ce qui se trouve à [red]*gauche de l'hexagone* représente [red]*les composants qui ont besoin de ce dernier*. +
On trouve côté gauche des *interfaces exposées pour les composants ayant besoin d'invoquer le modèle*. On parle d'*API*, pour _Application Provider Interfaces_. +
-> Les composants souhaitant communiquer avec notre métier le feront au travers d’*adaptateurs qui contacteront nos API*.

* Tout ce qui se trouve à [red]*droite de l'hexagone* représente [red]*les composants dont ce dernier a besoin*. +
On trouve côté droit des *interfaces exposées pour les composants que le modèle a besoin d’invoquer*. On parle de *SPI*, pour _Service Provider Interfaces_. +
-> Les composants avec lesquels notre métier souhaite communiquer seront contactés au travers des *SPI dont les implémentations seront résolues à l’exécution et fournies par des adaptateurs*.

=== Isolation

image::microservices-etat-des-lieux_03.jpg[]

Comme nous le verrons plus en détail par la suite, la notion d'*isolation* est capitale pour les microservices, or *l'isolation amène la redondance*, et cette dernière, on nous a appris à la "combattre" depuis des dizaines d'années. +
Rappelez-vous le principe introduit dans https://www.amazon.fr/Pragmatic-Programmer-Journeyman-Master/dp/020161622X[_The Pragmatic Programmer_] : *Don't Repeat Yourself (DRY)*.

Prenons le cas de 2 classes partageant un même comportement. +
Comme on nous l'a appris en programmation OO, on aura généralement tendance à sortir ce comportement commun dans une classe de plus haut niveau, qui sera ensuite héritée. +
Si on change le comportement de la classe mère, on impacte donc les 2 classes filles. +
Cet héritage a donc augmenté le couplage entre nos classes.

[NOTE]
====
L'exemple précédent est... juste un exemple pour illustrer un problème classique de couplage 😅 +
On pourrait faire différemment, en utilisant la composition ou d'autres patterns (ne me tappez pas... 😉)
====

Dans le cas des microservices, nous voulons éviter un maximum tout couplage, afin que ces derniers soient le plus *indépendants* possible.
Donc, entre *DRY et couplage*, et [red]*isolution et redondance*, la 2nd approche est privilégiée.

.DDD et redondance
[NOTE]
====
La conception des microservices plébiscite l'approche *DDD* (*Domain Driven Design*). +
Cette approche, tout particulièrement le découpage en *bounded context*, nous encourage très fortement à limiter le couplage, quitte à "se répéter" par moment. +
Ce qui fait pencher encore un peu plus la balance vers "l'isolation et redondance".

Si vous voulez plus de détails sur ce point, je vous conseille l'excellente conférence https://www.youtube.com/watch?v=xZOO_CksS-E[Hexagonal at Scale, with DDD and microservices!] de Cyrille Martraire, lors du Voxxed Days Microservices Paris 2018.
====

=== Pourquoi les microservices ?

Du fait du développement d’Internet, tout le monde communique avec tout le monde, et est en concurrence avec tout le monde. +
L’émergence des microservices est la conséquence de l’*évolution de nos applications* pour faire face à ces nouveaux besoins :

* *Complexité croissante* +
Les applications ne se limitent plus au seul data center de la compagnie, mais communiquent avec les services externes d’autres providers sur tout le globe.
* *Besoin de livrer de plus en plus vite* +
Quand la concurrence est partout, il faut pouvoir faire évoluer son produit rapidement, et donc être capable de livrer des nouvelles fonctionnalités au plus tôt, sans devoir attendre de release complète.
* *Besoin de performance et de scalabilité* +
Il faut être capable de s’adapter aux montées en charge d’un marché potentiellement mondial : très vite scaler sur de multiples serveurs, et libérer les ressources tout aussi vite quand le pic de charge est passé.
* *Doivent être toujours disponibles* +
Du fait de la compétition de plus en plus sauvage, si votre application tombe, votre client part chez le concurrent... Votre application doit être résiliente, et être capable de gérer les pannes (on parlera pour cela de _"Design for Failures"_).

Pour adresser ces problématiques, des sociétés comme Netflix, Amazon, eBay commencèrent à *casser leurs monolithes* en services :

* de petite taille, chacun ne remplissant qu’une fonction
* pouvant être *déployés indépendamment* les uns des autres.

Ces services *distribués*, *petits*, *simples* et *découplés* permirent aux applications de devenir *scalables*, *résilientes* et *flexibles*. +
-> Ils prirent progressivement le nom de *microservices*.

NOTE: La *découpe des applications monolithiques* en microservices est donc le *Use Case d’origine* des microservices.
