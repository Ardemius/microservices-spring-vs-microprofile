= Microservices : un Ã©tat des lieux
Thomas SCHWENDER <https://github.com/ardemius[@ardemius]>
// Handling GitHub admonition blocks icons
ifndef::env-github[:icons: font]
ifdef::env-github[]
:status:
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]
:imagesdir: ./images
:source-highlighter: highlightjs
// Next 2 ones are to handle line breaks in some particular elements (list, footnotes, etc.)
:lb: pass:[<br> +]
:sb: pass:[<br>]
// check https://github.com/Ardemius/personal-wiki/wiki/AsciiDoctor-tips for tips on table of content in GitHub
:toc: macro
:toclevels: 2
// To turn off figure caption labels and numbers
:figure-caption!:

toc::[]

== Microservices : un rien d'histoire et de contexte

On peut voir lâ€™*architecture microservices* comme une Ã©volution lâ€™architecture *SOA* (Service Oriented Architecture), elle-mÃªme crÃ©Ã©e pour pallier aux inconvÃ©nients des *applications monolithiques*.

image:microservices-etat-des-lieux_01.jpg[]

* Un des points intÃ©ressants Ã  remarquer dans la transition SOA vers lâ€™architecture microservices, est la *suppression de lâ€™ESB* (Enterprise Service Bus). +
La communication entre les services devait Ãªtre la principale fonction de ce composant, mais il embarquait frÃ©quemment une *trop grande complexitÃ© mÃ©tier*. +
Pour corriger cela, il a Ã©tÃ© *remplacÃ© par les endpoints REST des microservices*. +
Pour illustrer ce changement, Martin Fowler palera de _"Smart endpoints and Dumb pipes"_

* On constate Ã©galement que l'on ne travaille plus avec un seul et unique runtime, mais avec *1 runtime par microservice*, ce qui participe Ã  garantir une de leurs principales caractÃ©ristiques :  l'*isolation*.

=== L'inspiration des microservices

En 2005, Alistair Cockburn prÃ©sentait lâ€™*architecture hexagonale* (ou modÃ¨le *â€œPorts and Adaptersâ€*) afin de permettre la conception dâ€™applications pouvant Ãªtre testÃ©es en *isolation de leurs runtimes et bases de donnÃ©es*.

Cela a Ã©tÃ© lâ€™inspiration pour lâ€™architecture microservices, dont Alistair donna ensuite la dÃ©finition suivante : _â€œAn architectural style or an approach for building IT systems as a set of business capabilities that are autonomous, self contained, and loosely coupledâ€_

=== Architecture hexagonale

image::microservices-etat-des-lieux_02.jpg[]

IMPORTANT: Le principe fondateur de ce pattern est que [red]*le mÃ©tier ne doit dÃ©pendre de rien* : TOUTES les dÃ©pendances vont de *lâ€™extÃ©rieur vers lâ€™intÃ©rieur*.

Le but principal de cette architecture ne date pas d'hier, il est question de *sÃ©parer clairement le mÃ©tier de l'implÃ©mentation technique* (notion d'*isolation*).

* Tout ce qui se trouve Ã  [red]*gauche de l'hexagone* reprÃ©sente [red]*les composants qui ont besoin de ce dernier*. +
On trouve cÃ´tÃ© gauche des *interfaces exposÃ©es pour les composants ayant besoin d'invoquer le modÃ¨le*. On parle d'*API*, pour _Application Provider Interfaces_. +
-> Les composants souhaitant communiquer avec notre mÃ©tier le feront au travers dâ€™*adaptateurs qui contacteront nos API*.

* Tout ce qui se trouve Ã  [red]*droite de l'hexagone* reprÃ©sente [red]*les composants dont ce dernier a besoin*. +
On trouve cÃ´tÃ© droit des *interfaces exposÃ©es pour les composants que le modÃ¨le a besoin dâ€™invoquer*. On parle de *SPI*, pour _Service Provider Interfaces_. +
-> Les composants avec lesquels notre mÃ©tier souhaite communiquer seront contactÃ©s au travers des *SPI dont les implÃ©mentations seront rÃ©solues Ã  lâ€™exÃ©cution et fournies par des adaptateurs*.

=== Isolation

image::microservices-etat-des-lieux_03.jpg[]

Comme nous le verrons plus en dÃ©tail par la suite, la notion d'*isolation* est capitale pour les microservices, or *l'isolation amÃ¨ne la redondance*, et cette derniÃ¨re, on nous a appris Ã  la "combattre" depuis des dizaines d'annÃ©es. +
Rappelez-vous le principe introduit dans https://www.amazon.fr/Pragmatic-Programmer-Journeyman-Master/dp/020161622X[_The Pragmatic Programmer_] : *Don't Repeat Yourself (DRY)*.

Prenons le cas de 2 classes partageant un mÃªme comportement. +
Comme on nous l'a appris en programmation OO, on aura gÃ©nÃ©ralement tendance Ã  sortir ce comportement commun dans une classe de plus haut niveau, qui sera ensuite hÃ©ritÃ©e. +
Si on change le comportement de la classe mÃ¨re, on impacte donc les 2 classes filles. +
Cet hÃ©ritage a donc augmentÃ© le couplage entre nos classes.

[NOTE]
====
L'exemple prÃ©cÃ©dent est... juste un exemple pour illustrer un problÃ¨me classique de couplage ðŸ˜… +
On pourrait faire diffÃ©remment, en utilisant la composition ou d'autres patterns (ne me tappez pas... ðŸ˜‰)
====

Dans le cas des microservices, nous voulons Ã©viter un maximum tout couplage, afin que ces derniers soient le plus *indÃ©pendants* possible.
Donc, entre *DRY et couplage*, et [red]*isolution et redondance*, la 2nd approche est privilÃ©giÃ©e.

.DDD et redondance
[NOTE]
====
La conception des microservices plÃ©biscite l'approche *DDD* (*Domain Driven Design*). +
Cette approche, tout particuliÃ¨rement le dÃ©coupage en *bounded context*, nous encourage trÃ¨s fortement Ã  limiter le couplage, quitte Ã  "se rÃ©pÃ©ter" par moment. +
Ce qui fait pencher encore un peu plus la balance vers "l'isolation et redondance".

Si vous voulez plus de dÃ©tails sur ce point, je vous conseille l'excellente confÃ©rence https://www.youtube.com/watch?v=xZOO_CksS-E[Hexagonal at Scale, with DDD and microservices!] de Cyrille Martraire, lors du Voxxed Days Microservices Paris 2018.
====

=== Pourquoi les microservices ?

Du fait du dÃ©veloppement dâ€™Internet, tout le monde communique avec tout le monde, et est en concurrence avec tout le monde. +
Lâ€™Ã©mergence des microservices est la consÃ©quence de lâ€™*Ã©volution de nos applications* pour faire face Ã  ces nouveaux besoins :

* *ComplexitÃ© croissante* +
Les applications ne se limitent plus au seul data center de la compagnie, mais communiquent avec les services externes dâ€™autres providers sur tout le globe.
* *Besoin de livrer de plus en plus vite* +
Quand la concurrence est partout, il faut pouvoir faire Ã©voluer son produit rapidement, et donc Ãªtre capable de livrer des nouvelles fonctionnalitÃ©s au plus tÃ´t, sans devoir attendre de release complÃ¨te.
* *Besoin de performance et de scalabilitÃ©* +
Il faut Ãªtre capable de sâ€™adapter aux montÃ©es en charge dâ€™un marchÃ© potentiellement mondial : trÃ¨s vite scaler sur de multiples serveurs, et libÃ©rer les ressources tout aussi vite quand le pic de charge est passÃ©.
* *Doivent Ãªtre toujours disponibles* +
Du fait de la compÃ©tition de plus en plus sauvage, si votre application tombe, votre client part chez le concurrent... Votre application doit Ãªtre rÃ©siliente, et Ãªtre capable de gÃ©rer les pannes (on parlera pour cela de _"Design for Failures"_).

Pour adresser ces problÃ©matiques, des sociÃ©tÃ©s comme Netflix, Amazon, eBay commencÃ¨rent Ã  *casser leurs monolithes* en services :

* de petite taille, chacun ne remplissant quâ€™une fonction
* pouvant Ãªtre *dÃ©ployÃ©s indÃ©pendamment* les uns des autres.

Ces services *distribuÃ©s*, *petits*, *simples* et *dÃ©couplÃ©s* permirent aux applications de devenir *scalables*, *rÃ©silientes* et *flexibles*. +
-> Ils prirent progressivement le nom de *microservices*.

NOTE: La *dÃ©coupe des applications monolithiques* en microservices est donc le *Use Case dâ€™origine* des microservices.
